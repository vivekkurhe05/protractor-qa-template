# Project structure should be simple and effective

A good project structure helps everyone catch up quicker with the project no matter how bigger and complex a project is! Because it makes things easier to find and tackle the problems, allows cleaner folder structure. Below structure is more readable and also lowers the number of files in a project and separates the page-objects and test scripts in a good manner.

![Framework structure](img/project_st.png)

1. The first section is src and its sub-folders where Javascript code should be placed written by QA Automation Engineer. The src folder should contain following sub-folders
    a. conf
    b. helpers
    c. page-objects
    d. specs

2. The last node_modules folder is automatically generated by installing new libraries using npm tool. So we should not modify its contents manually.


# Follow Page object model approach

Because it removes bad design problem
Three major bad design problems are

1. Code duplication
2. Maintainence problem
3. Hard to understand

# One Spec file, One page object class

There should be a page object file corresponding to a spec file. Because it is easy to find relevant page object class for a test script.


# Use a single module.exports at the end of the page object file

Each page object should declare a single class. You only need to export only one class.

![Single module.exports](img/home.png)

One spec file, One page object class means there is only one class to export.


# Declare require modules at the top of the file

You should declare all the required modules at the top of page-object class, helpers, specs.

![Module Declaration](img/import.png)

Because the module dependencies should be clear and easy to find.


# Declare all the page object public elements in the constructor

All the elements that will be visible to the test should be declared in the constructor.

![Declaration of page objects in the constructor](img/constructor.png)

Because the user of the page object should have quick access to the available elements on  a page.


# Keep good coding conventions for page objects classes

1. File name should have similar name as page object class. The name should be in lower case separated by underscore “_”.
**For e.g. -** If we are testing **Home** page, then filename should be **home_page.js**
2. Page object class should have the same name as file name. Class name should be in CamelCase with first letter in uppercase.
**For e.g. - HomePage**
3. Page object’s methods should be in CamelCase with first letter in lowercase.
**For e.g. - enterFieldValue(), getDynamicTest(), clickContinue(), etc.**
4. Methods of page objects should return a page object if you are navigating from one page to another.


# Handling Javascript asynchronous behaviour using async and await

**async** and **await** feature in javascript is helpful to deal with asynchronous behaviour. Following few lines illustrate the problem with javasacript’s asynchronous behaviour

![without async and await](img/noasync_await.png)

You may be thinking that getText() method will return some text. But, actually, the method returns undefined because the nature of the Javascript is to not wait for the function to be completed before calling another function. We can simply resolve this issue by placing async and await keywords in the code as below.

![async and await](img/async_await.png)


# Page object’s method should wait for the page to be loaded completely before exiting

For some page object’s methods which result the changes in the AUT such as reloading page or redirecting to other pages, we should add atleast one line of code to wait for the destination page to be fully loaded before exiting the current method. For example, we can wait for a component to be visible or wait for a spinner to be disappeared.

![Wait for the page load](img/page.png)


# Locator strategies

we should avoid using xpath, if possible.
Why?
    1. It is the slowest and most brittle strategy of all.
    2. Markup is very easily subjected to change and therefore xpath locators require a lot of maintainance.
    3. Xpath expressions are unreadable and very hard to debug.

For e.g. -  

![locator strategy](img/xpath_new.png)


# Prefer protractor locator strategies when possible

We should prefer protractor specific locators such as **by.binding**, **by.buttonText** and **by.model** etc.
why?
    1. These locators are usually specific, short, and easy to read.
    2. It is easier to write your locator.
    3. The code is less likely to change than other markup.

For e.g. -

![short and easy locator strategy](img/model_buttonText.png)


# Prefer by.id and by.css when no protractor locators are available

why?
    1. Both are very performant and readable locators.
    2. Access elements easier.

For e.g. - 

![Preferable locators](img/preferable_locators.png)


# Avoid text locators for text that changes frequently

Try to avoid text based locators such as **by.linkText**, **by.cssContainingText**

why?
    1. Text for buttons, links and labels tends to change over time.
    2. Your text should not break when you make minor text changes.

For e.g. -

![Text based locators](img/avoidLocators.png)


# Test script should only call page object’s methods 

This is a rule of thumb for boosting code reusability and maintainability. Even if you just need to click on a control, you still have to wrap the interaction in a page object’s method and call it from the test side. Doing this, when either the requirement or the AUT’s design is changed, makes the only place needing to be refactored just the page object’s method.

Below example shows us a very good way to implement the test.

    1. Write steps of action in page object class

For e.g. -

![Steps of action](img/page.png)

    2. And call this method in test script as below

For e.g. -

![Test script calling page-object methods](img/testScript.png)


# Do not place assertions inside page object classes

If you are placing verification points inside page object classes, you are making test script complicated. Our suggestion is to have page object classes help interact with the AUT and also get what we need from the AUT . Then, we can use what we got to fulfill the test’s assertions. By doing this, we will take back the original responsibility of the tests and make the code clearer by avoiding hidden assertions in the page object classes.

For e.g. -

![No assertion in page object](img/assertions.png)


# Make your tests independent

Protractor can run your tests in parallel when you enable sharding. The files are executed across different browsers as they become available.

Make your tests independent at the file level because the order in which they run is not guaranteed and it is easier to run a test in isolation.


# Make your test automation framework portable

It is a very bad practice for automation frameworks that require huge efforts to run them on another machine, unlike the one which was used for framework creation because it doesn’t allow other team members to run tests, without struggling with setup troubles. And what if you want to run your tests on CI server? It would be a very tricky task if your UI test automation framework is not portable. 

Do not store test automation files on your local machine. If you have test automation files that are required for test automation, they should be attached to your framework.


# Use data-driven instead of repeated tests 

Data-driven tests are extremely useful when you need to test the same workflow by using different data. For example, if you want to verify the login functionality, this is how tests would look like without data-driven approach

![Tests without data-driven approach](img/no_data_driven.png)

But what if you need to test many combinations? Our test will grow and become unhandy to use and unmaintainable. That’s where data-driven approach can give you a huge benefit. By using data-driven tests, you can use only one test and one array of data, which we are going to use in order to run all the different data combinations.

![Data Driven approach](img/data_driven.png)

Now you  have just  one that you need to maintain. If you want to write one more test with an additional combination, all you need is to add the additional combination to the test data array.

If you don’t have this mechanism yet or you have just started the creation of your UI test automation framework.


# Always take a screenshot for failure investigation

This best practice will help you save lot of your time when investigating the reasons for a test failure. You can implement a mechanism that will make a browser screenshot in case a test failed.


# Name your tests wisely

Test names should be very clear and provide a self-descriptive idea about which functionality is being tested by using this test. 
Why?
    1. You need to immediately understand what each test verifies even a year after you wrote a test.
    2. You should always help your team members and make all your tests clear for them.
    3. If some of the tests fail during tests execution, you should understand which functionality was broken just having a quick look at the test name.

![Example of test name](img/proper_test_name.png)


# Make use of Jasmine framework

Because,
    1. Jasmine is well documented
    2. It is supported by protractor out of the box
    3. You can use **beforeAll**, **afterAll**, **beforeEach**, **afterEach**

![Matchers of jasmine framework](img/jasmine.png)


# Use Jasmine spec reporter for better console report

Why?
Because this plugin is useful in improving the report that is displayed in the console window after your test has run.

The following screen is the example without plugin.

![Without reporter plugin](img/fullWithoutReporter.png)

The default format for the test reporter in protractor is a green dot and “F” for a failing test. The problem with this is you don’t have an easy way what tests passed. And you have to look into failure logs to see which tests failed.

But jasmine-spec-reporter plugin has streamlined the passed and failed tests to understand on console as shown below.

![With reporter plugin](img/fullWithReporter.png)















